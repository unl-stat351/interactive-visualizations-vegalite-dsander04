---
title: "Homework: Interactive Visualization with Vega-Lite"
author: "Dominic Sander"
format: html
theme: cosmo
---

# Introduction

In this assignment, you will create interactive charts using **Vega-Lite** inside a **Quarto document** with ObservableJS chunks.
Complete all sections and provide brief explanations for each chart.

```{ojs}
// This sets up observable JS
import {vl} from "@observablehq/vega-lite"
```

## Setting Up

For this lab, we'll use the XKCD Color survey data.
The TidyTuesday documentation is available [here](https://github.com/rfordatascience/tidytuesday/blob/main/data/2025/2025-07-08/readme.md).

Observable does best with data that's local, so we'll read the CSVs into R objects and write them out to local CSVs (yes, we could just download them... but this gives you the chance to do an exploratory data analysis in R if you prefer.)

```{r}
answers <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/main/data/2025/2025-07-08/answers.csv')
color_ranks <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/main/data/2025/2025-07-08/color_ranks.csv')
users <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/main/data/2025/2025-07-08/users.csv')

write.csv(answers, "data/answers.csv")
write.csv(color_ranks, "data/color_ranks.csv")
write.csv(users, "data/users.csv")
```

```{ojs}
// Imports
d3 = require("d3@7")
import {Inputs} from "@observablehq/inputs"

// Load color_ranks.csv (preferred) or sample fallback
raw = await FileAttachment("data/color_ranks.csv").csv({typed: false});

// Parse hex -> RGB/HSL
colors = raw.map(d => {
  const hex = d.hex?.trim();
  const name = d.color ?? d.name ?? d.Color ?? "unknown";
  const c = d3.color(hex);
  const hsl = d3.hsl(c);
  return {
    color: name,
    hex,
    rank: +d.rank,
    r: c?.r ?? NaN,
    g: c?.g ?? NaN,
    b: c?.b ?? NaN,
    h: ((hsl?.h ?? NaN) + 360) % 360,
    s: (hsl?.s ?? NaN) * 100,
    l: (hsl?.l ?? NaN) * 100
  }
}).filter(d => d.hex && !Number.isNaN(d.h) && !Number.isNaN(d.l))


// Parse hex -> RGB/HSL and compute a hue family bucket
allColors = raw.map(d => {
  const hex = d.hex?.trim();
  const name = d.color ?? d.name ?? d.Color ?? "unknown";
  const c = d3.color(hex);
  const hsl = d3.hsl(c);
  const h = ((hsl?.h ?? NaN) + 360) % 360;
  const s = (hsl?.s ?? NaN) * 100;
  const l = (hsl?.l ?? NaN) * 100;
  const family = (s < 10 || l > 95) ? "Grays/Whites" :
    (h < 15 || h >= 345) ? "Reds" :
    (h < 45) ? "Oranges" :
    (h < 70) ? "Yellows" :
    (h < 170) ? "Greens" :
    (h < 200) ? "Cyans" :
    (h < 255) ? "Blues" :
    (h < 290) ? "Purples" :
    (h < 330) ? "Pinks" : "Reds";
  return {color: name, hex, rank: +d.rank, r: c?.r ?? NaN, g: c?.g ?? NaN, b: c?.b ?? NaN, h, s, l, family}
}).filter(d => d.hex)
```
> This graph shows color lightness and hue on a cartesian plot with a slider allowing us to look at saturation as well. The hue is on the x-axis from 0-360 and lightness is on the y-axis on a scale from 0-100 in percent lightness. We also have a slider that allows us to filter for all points above a certain saturation level (also on a 0-100 scale).

# Interactive Exploration

I asked CoPilot to generate an observable plot that uses selectors to change the color space and saturation.
I've modified its code to both fix errors and explain more things using comments. 

It may help to bring up Wikipedia pages for [RGB](https://en.wikipedia.org/wiki/RGB_color_model) and [HSL](https://en.wikipedia.org/wiki/HSL_and_HSV) color models. 

```{ojs}
// selector for color space -- changes plot axes
viewof space = Inputs.select(["HSL", "RGB"], {label: "Color space (axes)", value: "HSL"})
// selector for color saturation/intensity
viewof minSat = Inputs.range([0, 100], {label: "Min saturation (%)", value: 0, step: 1})


// filter out points based on saturation
filtered = colors.filter(d => d.s >= minSat)

// Create an x variable that's conditional on what is selected,
// changing both the values and the label accordingly
xAccessor = space === "HSL" ? (d) => d.h : (d) => d.r
xLabel = space === "HSL" ? "Hue (°)" : "Red (0–255)"

// Create a y variable that's conditional on what is selected,
// changing both the values and the label accordingly
yAccessor = space === "HSL" ? (d) => d.l : (d) => d.g
yLabel = space === "HSL" ? "Lightness (%)" : "Green (0–255)"
```

```{ojs}
Plot.plot({
  grid: true, // show coordinate grid
  color: {legend: false}, // no need for legends when the data is colors
  marks: [
    Plot.dot(
      filtered, // use filtered data
      {
        x: xAccessor, y: yAccessor, // specify mappings
        fill: (d) => d.hex,
        stroke: "#333", strokeWidth: 0.5, r: 5, // and defaults
        tip: true,
        // title = tooltip text. use both color name and hex value
        title: d => `${d.color} (${d.hex})
  HSL: ${d.h.toFixed(0)}, ${d.s.toFixed(0)}%, ${d.l.toFixed(0)}%
  RGB: ${d.r}, ${d.g}, ${d.b}`
      }
    )],
  x: {label: xLabel, domain: space === "HSL" ? [0, 360] : [0, 255]},
  y: {label: yLabel, domain: space === "HSL" ? [0, 100] : [0, 255]},
  caption: space === "HSL" ? "Hue vs. Lightness (filtered by min saturation)." : "Red vs. Green (still filtered by HSL saturation)."
})
```

## Alternatives

Can you think of a better way to display this data, potentially using similar selectors? Describe the changes you'd make. 

> We could display this data in polar coordinates instead so you can more easily see the continuum of colors. Darker colors can be displayed closer to the center (or outside) and lighter colors can be displayed closer to the outside (or center). Also, if we're being honest, I can't see any difference between the HSL and RGB graphs. If they were both necessary for whatever I wanted to show, I could definitely keep both of them, but at this point I don't think I need it. 

Is your proposed graphic supported by vega-lite? Why or why not? (You can provide links to documentation/stackOverflow)

> From what I've been able to find, vega-lite does not have a specified polar coordinates function or plot. There are arcs I could try to use to define what I want the coordinate plot to look like.

>https://vega.github.io/vega-lite/docs/encoding.html#polar - this is the documentation tab on the vegalite github site. About half way down the page it briefly discusses the use of theta and radius in vegalite. 

>https://vega.github.io/vega-lite/docs/arc.html - this is also documentation on how to use the arc function - specifically with how to make pie charts. While that's not exactly what we're trying to make, I think having values from 0-360 degrees in our data will help. I'd need to do a little bit of experimenting to see if this type of chart would be allowed because all of the examples are only pie or donut charts which do not help us in showing the hues graph better. 


## Adding selectors

Add a `maxSat2` selector that puts an upper bound on the saturation. 
To ensure mathematical viability, your `maxSat2` selector should have a lower bound of `minSat2`.
Wire your `maxSat2` selector to the plot, using the chunk below, which I've edited to use variables with `2` at the end to not conflict with the original chart. 


```{ojs}
// selector for color space -- changes plot axes
viewof space2 = Inputs.select(["HSL", "RGB"], {label: "Color space (axes)", value: "HSL"})
// selector for color saturation/intensity
viewof minSat2 = Inputs.range([0, 100], {label: "Min saturation (%)", value: 0, step: 1})
// selector for color saturation/intensity
viewof maxSat2 = Inputs.range([minSat2,100], {label: "Max saturation (%)", value: 100, step: 1})


// filter out points based on saturation
filtered2 = colors.filter(d => d.s >= minSat2).filter(d => maxSat2 >= d.s)

// Create an x variable that's conditional on what is selected,
// changing both the values and the label accordingly
xAccessor2 = space === "HSL" ? (d) => d.h : (d) => d.r
xLabel2 = space === "HSL" ? "Hue (°)" : "Red (0–255)"

// Create a y variable that's conditional on what is selected,
// changing both the values and the label accordingly
yAccessor2 = space === "HSL" ? (d) => d.l : (d) => d.g
yLabel2 = space === "HSL" ? "Lightness (%)" : "Green (0–255)"
```

```{ojs}
Plot.plot({
  grid: true, // show coordinate grid
  color: {legend: false}, // no need for legends when the data is colors
  marks: [
    Plot.dot(
      filtered2, // use filtered data
      {
        x: xAccessor2, y: yAccessor2, // specify mappings
        fill: (d) => d.hex,
        stroke: "#333", strokeWidth: 0.5, r: 5, // and defaults
        tip: true,
        // title = tooltip text. use both color name and hex value
        title: d => `${d.color} (${d.hex})
  HSL: ${d.h.toFixed(0)}, ${d.s.toFixed(0)}%, ${d.l.toFixed(0)}%
  RGB: ${d.r}, ${d.g}, ${d.b}`
      }
    )],
  x: {label: xLabel2, domain: space === "HSL" ? [0, 360] : [0, 255]},
  y: {label: yLabel2, domain: space === "HSL" ? [0, 100] : [0, 255]},
  caption: space === "HSL" ? "Hue vs. Lightness (filtered by min and max saturation)." : "Red vs. Green (still filtered by HSL saturation)."
})
```

